## 1. 도커

- 교재: 도커/쿠버네티스를 활용한 컨테이너 개발 실전 입문 .

### 도커란 무엇인가?
`도커`는 컨테이너형 가상화 기술을 구현하기 위한 상주 애플리케이션과 이 애플리케이션을 조작하기 위한 명령형 도구로 구성되는 프로덕트다. 애플리케이션 배포에 특화돼 있기 때문에 애플리케이션 개발 및 운영을 컨테이너 중심으로 할 수 있다.

### 도커의 역사
2013년 봄 닷클라우드사의 엔지니어였던 솔로몬 하익스가 최초로 도커를 오픈 소스로 공개했다. 이때부터 그 편리함 덕분에 도커는 점차 널리 퍼져 나갔다. 

오케스트레이션 도구 Fig를 인수 - 현재의 도커 컴포즈 

2014년부터는 도커 관련 컨퍼런스 DockerCon이 매년 개최

### 도커의 기본 개념
도커는 컨테이너형 가상화를 구현하기 위한 상주 애플리케이션과 이를 관리하는 명령형 도구로 구성된다. 

#### 컨테이너형 가상화 기술
도커는 `컨테이너형 가상화 기술`(운영체제수준가상화)을 사용한다. 
도커 이전에는 LXC가 유명했는데 도커도 초기에는 컨테이너형 가상화를 구현하는데 LXC를 런타임으로 사용(현재runC를 사용) 했다.
컨테이너형 가상화를 사용하면 소프트웨어 없이도 운영 체제의 리소스를 격리해 가상 운영 체제로 만들 수 있다. 이 가상 운영 체제를 컨테이너라고 한다. 
![imgUrl](https://miro.medium.com/max/1400/1*wOBkzBpi1Hl9Nr__Jszplg.png)


#### 애플리케이션이 중심이 되는 도커
문제점: LXC는 설정의 차이로 다른 OS에서 구동이 되지 않는 현상이 발생함.
도커와 LXC의 차이점
- 호스트 운영체제의 영향을 받지 않는 실행환경(Docker Engine을 이용한 실행 환경 표준화)
- DSL(Dockerfile)을 이용한 컨테이너 구성 및 애플리케이션 배포 정의
- 이미지 버전 관리
- 레이어 구조를 갖는 이미지 포맷(차분 빌드가 가능함)
- 도커 레지스트리(이미지 저장 서버 역할을 함)
- 프로그램 가능한 다양한 기능의 API
도커는 컨테이너 정보를 Dockerfile 코드로 관리할 수 있다. 이 코드를 기반으로 복제 및 배포가 이루지기 때문에 재현성이 높은 것이 특징이다. 

### 도커 스타일 체험하기
1. 스크립트 작성
```
#!/bin/sh
echo "hello, world!"
```  

2. 스크립트를 도커에 담아보자.
```
FROM ubuntu:16.04

COPY helloworld /usr/local/bin
RUN chmod +x /usr/local/bin/helloworld

CMD ["helloworld"]
```  

*1. FROM: 운영체제 정의*  
*2. COPY: 셀스크립트 파일을 도커컨테이너 안의 /usr/local/bin에 복사*  
*3. RUN: 도커 컨테이너 안에서 어떤 명령을 수행*  
*4. CMD: 완성된 이미지를 도커 컨테이너로 실행하기 전에 먼저 실행할 명령을 정의 한다.*  

3. Dockerfile을 사용해 이미지를 빌드
```
$ docker image build -t helloworld:latest .
```  

4. 도커 실행
```
$ docker container run helloworld:latest
```  

### 더 실용적인 예제
한번 실행되면 끝나는 어플리케이션이 아닌 계속 실행된 상태 어플리케이션 만들기  
node.js 버전의 기반 이미지를 이용하되, npm으로 모듈을 추가 설치하거나 애플리케이션 빌드를 컨테이너 안에서 수행해 이미지를 만든다.  
호스트 운영체제에 node.js나 npm을 설치할 필요가 없다.  
<u>이건 혼자서 만들어 보라는 소리?</u>  

### 도커를 사용하는 의의
- 변화하지 않는 실행환경으로 멱등성 확보
- 코드를 통한 실행 환경 구축 및 애플리케이션 구성
- 실행 환경과 애플리케이션의 일체화로 이식성 향상
- 시스템을 구성하는 애플리케이션 및 미들웨어의 관리 용이성

웹 어플리케이션의 프론트앤드에 아파치나 엔진엑스 같은 웹서버를 두는 것도 복잡한 절차 없이 컨테이너로 설정할 수 있게 된다. 미들웨어를 포함하는 시스템 구성 역시 설정 파일로 정의할 수 있다. 도커를 도입하면 개발 및 운영 업무가 쉬워진다.
> 도커 도입이 진정 개발 및 운영 업무를 쉽게 만들어 줄까? - 각자의 의견을 듣고 싶어요!

#### 도커 도입전 문제점 
> B 서버에서도 같은 애플리케이션을 배포하고 싶은데, 애플리케이션 A 서버와 다르게 동작하네  
> 모든 서버에 같은 아카이브를 배포하고 싶은데...,  
> 서버 설정과 설치된 라이브러리가 서버마다 다르면 어쩌지?  
> B 서버에 설치된 라이브러리가 버전은 낮은 거였네, 업데이트 해야 겠다.  
> 서버 상태를 똑같이 유지하는 수단이 필요하겠어  

#### 근복적인 원인
*인프라의 가변성을 허용*

애플리케이션을 항상 뭔가에 의존성을 갖는다. 운영체제는 물론이고, CPU나 메모리 같은 컴퓨터 리소스, 언어 런타임, 라이브러리, 애플리케이션 내부적으로 별도 프로세스로 실행하는 다른 애플리케이션 등 다양한 요소에 의존성을 가질 수 있다. 

각 서버에 배포된 애플리케이션이 동일하다면, 애플리케이션이 의존하는 환경의 차이를 가능한 한 배제 하는 것이 이 문제를 해결하는 지름길이다. 

#### 코드로 관리하는 인프라와 불변 인프라
코드로 관리하는 인프라는 코드 기반으로 인프라를 정의한다는 개념이다. 
서버를 어떻게 구성할 것인지, 어떤 라이브러리 도구를 설치할지를 코드로 정의하고 셰프나 앤서블 같은 프로비저닝 도구로 서버를 구축한다. 수작업이 개입할 여지를 줄이고 코드 중심으로 바꿈으로써 쉽게 같은 구성의 서버 여러 대를 복제할 수 있다. 

***코드로 관리하는 인프라 역시 만병 통치약은 아니다.***
아래의 경우를 보자.
```bash 
$ nodebrew install-binary stable
```
이것은 Node.js 버전 관리 도구인 nodebrew에서 안정 버전(stable)을 설치하도록 설정하는 명령이다. stable이 가리키는 버전은 생각보다 자주 변하기 때문에 이런 방식으로는 항상 같은 결과가 보장되지 않는다. 환경 차이 문제를 피하려면 언제든 몇 번을 실행해 같은 결과가 보장되는 멱등성을 확보해야 한다. 애플리케이션이 의존하는 런타임이나 라이브러리 모두가 확실하게 특정 버전으로 설치되도록 코드를 작성해야 한다.

그러나 `항구적인 코드`를 계속 작성하는 것은 운영 업무에 부담을 주기 쉽다.

이 문제의 해결방안은 `불변 인프라 개념`이다. 불변 인프라는 `어떤 시점의 서버 상태를 저장`해 복제할수 있게 하자는 개념이다. 제대로 설정된 상태의 서버를 항상 사용할 수 있다는 점이 가장 큰 장점이다. 

서버에 변경을 가하고 싶은 경우에는 기존 인프라를 수정하는 대신 `새로운 서버를 구축`하고 `그 상태를 이미지로 저장`한 다음 그 `이미지를 복제`한다. 한번 설정된 서버는 수정 없이 파기되므로 멱등성을 신경쓸 필요조차 없다. 

도커를 사용하면 코드로 관리하는 인프라와 불변 인프라의 두 개념을 간단하고 낮은 비용으로 실현할 수 있다. 
인프라 구성이 Dockerfile로 관리되므로 코드로 관리하는 인프라는 도커의 대원칙이다. 

도커는 도커 이미지(Dockerfile)로 서버 구성을 코드로 관리할 수 있다. 그러므로 기존 컨테이너를 빠르게 폐기하고 새로이 구축할 수 있다. 코드로 관리하는 인프라와 불변 인프라라는 두 개념 모두를 쉽게 구현할 수 있는 도구라고 할 수 있다. 

최근 아마존이나 GCP 같은 플랫폼은 가상머신을 쉽게 만들고 파기할 수 있는 시대이긴 하지만 호스트 가상화 방식에서는 가상머신을 시작하는데 적어도 1분에서 수분까지 시간이 걸린다. 호스트 가상화 기술은 가상화 소프트웨어로 컴퓨터 리소스를 추상화하는 방식이기 때문이다. 클라우드에서 도커를 사용할 때도 이런 점을 감안하는 것이 좋다.

#### 애플리케이션과 인프라 묶어 구축하기
도커에서 제공하는 인프라 관리와 애플리케이션 배포 개념도 도커의 장점 중 하나다. 
운영체제와 어플리케이션을 함께 담은 상자 같은 개념이다
컨테이너는 도커 이미지 형태로 저장하고 재사용할 수 있다.

### 애플리케이션 구성 관리의 용이성
도커 컨테이너는 애플리케이션과 인프라를 함께 담은 상자이다. 일정 규모를 넘는 시스템은 주로 여러개의 애플리케이션과 미들웨어를 조합하는 형태로 구성한다.
도커를 사용함으로써 배포 작업이 매우 쉬워지기는 했지만, 복잡한 시스템을 한덩어리로 동작시키기는 쉽지 않다. 

#### 도커 컨테이너 오케스트레이션 시스템
여러 컨테이너를 사용하는 애플리케이션을 쉽게 관리할 수 있도록 도커 컴포즈라는 도구를 제공한다. 

```yaml
version: "3"
services: 
    web:
        image: gihyodocker/web
        ports:
            - "3000":"3000"
        enviroment:
            REDIS_TARGET: redis
        depends_on:
            - redis
    redis:
        image: "redis:alpine"
```  

도커와 `도커 컴포즈`를 통해 `여러 애플리케이션과 미들웨어의 의존관계를 간결한 코드`로 관리할 수 있다. `도커 컴포즈`가 `단일 서버`를 넘어 `여러 서버`에 걸쳐 있는 여러 컨테이너를 관리할 수 있도록 한 도구가 `도커 스윔`이다. 
`도커 스윔`은 컨테이너 증가 혹은 감소는 물론이고 노드의 리소스를 효율적으로 활용하기 위한 컨테이너 배치 및 로드 밸런싱 기능 등 더욱 실용적인 기능을 갖추고 있다.
또, 배포 시에도 롤링 업데이트(오래된 컨테이너와 새로운 컨테이너를 단계적으로 서비스에 교체 투입하는 것)가 가능해 운영 면에서도 장점이 많다. 여러 서버에 걸쳐 있는 여러 컨테이너를 관리하는 기법을 컨테이너 `오케스트레이션` 이라고 한다.

컨테이너 오케스트레이션 분야에서 사실상 표준으로 자리 잡은 것은 쿠버네티스다. 쿠버네티스는 구글이 오랫동안 컨테이너를 운영하면서 얻은 노하우를 담은 오픈소스 소프트웨어다
도커 스윔보다 기능이 충실하며 확장성이 높다.  

### 운영 환경에서 빛을 발하는 도커
> - 도커의 신뢰성에 대한 의문
> - 성능 면에서의 우려
> - 현실적으로 운영이 가능한지에 대한 우려  

이러한 생각은 쓸데없는 생각이다. 운영 환경이야말로 도커가 빛을 발하는 자리다. 최근 몇년동안 도커는 전 세계 운영 환경에 도입됐으며 확실히 주류에 편입되고 커뮤니티의 성숙과 함께 신뢰성도 인정받았다. 성능 면에서도 스케일 아웃이 쉽다는 장점이 있음에도 오버헤드는 매우 적다.

데이터 스토어처럼 도커를 운영하기 어려운 분야도 존재한다. 

높은 이식성이라는 장점을 고려하면 도커는 운영환경에서 그야말로 제 능력을 발휘할 수 있는 기술이다. 이미 여러 실적을 거둔 바 있으며 클라우드에서도 매니지드 서비스를 통해 쉽게 다룰 수 있다. 

### 새로운 개발 스타일
인프라와 애플리케이션의 설정을 모두 코드 수준에서 쉽게 수정할 수 있게 됐다.
기존에는 명확했던 인프라 엔지니어와 서버 사이드 엔지니어의 영역 구분이 점점 희미해지고 있다. 
마이크로서비스 + 도커 궁합짱
개발에 외부API를 사용하는 경우에도 도커가 제공하는 목업 서버 개발 환경을 사용하는 경우가 늘고 있다. 안드로이드 개발을 예로 들면 도커가 CI 속도를 빠르게 하는 데 효율적이다.

도커는 인프라 엔지니어와 서버 사이드 엔지니어의 전유물이 아니다. 현대적인 개발을 수행한다면 프론트 엔드 엔지니어와 모바일 애플리케이션 엔지니어에게도 기초 기술이 될 것이다.


### 로컬 도커 환경 구축하기 
여기서는 윈도우용/macOS용 도커를 기준으로 설치하는 방법을 설명한다. 

#### 도커설치 파일 아래 다운로드 후 진행
도커는 커뮤니티 무료 버전을 받자  
https://hub.docker.com/editions/community/docker-ce-desktop-windows?tab=description  

#### 윈도우/macOS용 도커 기본 설정
- 도커 자동실행 체크  
- 자동 업데이트 확인 체크해제  
- 호스트 운영 체제 디렉토리 마운트  
- 가상 디스크 용량 설정  
- CPU 코어 및 메모리 할당  
- 프록시  
- 비보안 레지스트리  
- 쿠버네티스 체크 설정  
- 모든 데이터 삭제: 도커 막 설치한 초기상태 된다.  
- 도커 제거: 컨테이너 및 이미지도 모두 함께 파기된다  
- 도커 툴박스 설치: 가상머신에서 설치  

> 도커CE, EE 선택중 기업용에 걸맞은 기술 지원이 필요하다면 도커 EE의 도입을 검토해야 함.

## 도커 컨테이너 배포 
도커의 기본 조작 방법을 배우고, 애플리케이션을 배포하는 과정까지 알아본다.

### 컨테이너로 애플리케이션 실행하기
- 도커이미지: 도커컨테이너를 구성하는 파일시스템과 애플리케이션 설정을 하나로 합친것으로 컨테이너를 생성하는 템플릿 역할을 한다.  
- 도커컨테이너: 도커 이미지를 기반으로 생성되며, 파일시스템과 애플리케이션이 구체화돼 실행되는 상태  

### 도커이미지와 도커 컨테이너

```
$ docker image pull gihyodocker/echo:latest
$ docker container run -t -p 9001:8000 gihyodocker/echo:latest
$ curl http://localhost:9001
```

### 간단한 애플리케이션과 도커 이미지 만들기


1. 노드를 설정한다.  
```
npm init -f
npm i --save express build
```  

2. 소스를 작성한다.  
```javascript
// 디팬던시
var express = require('express');
var uuid = require('uuid');

var app = express();
var id = uuid.v4();
var port = 3000;

app.get('/', function (req, res) {
res.send(id)
});

app.listen(port, function () {
console.log('Example app listening on port: ' + port);
});
```  

3. 실행한다.  
```bash
node index.js
```  

4. 주의  
> node_modules을 직접 복사하는 일이 없도록 .dockerignore 파일을 작성한다. 

5. Dockerfile 작성  

```yaml
FROM node:6
COPY package.json /src/package.json
RUN cd /src; npm install
COPY . /src
EXPOSE 3000
WORKDIR /src

CMD node index.js
```  

#### FROM 인스트럭션

#### RUN 인스트럭션

#### COPY 인스트럭션

#### CMD 인스트럭션

### 도커 이미지 빌드

```
$ docker build --tag node-nginx:test .
$ docker images
```  
### 도커 컨테이너 실행

```
$ docker run --name node-nginx-instance -p 3000:3000 node-nginx:test
$ docker ps
```  

### 포트 포워딩

애플리케이션은 3000 포트를 리스닝 하고 있지만, 이 포트는 컨테이너 포트라고 해서 컨테이너 안에 한정된 포트이다. 컨테이너 안에서 호출하면 3000을 호출하면 응답을 제대로 받겠지만 외부에서 찌르면 받을 수 없다. 밖에서 온 요청을 컨테이너 안에 있는 어플리케이션에 전달해줘야 하는데 이 역할을 담당하는 것이 바로 도커의 포트 포워딩이다. 

-p 옵션값은 호스트_포트:컨테이너_포트 형식으로 기술하면 된다. 

호스트 포트를 다음과 같이 생략 가능하다.  
이런 경우에는 빈 포트가 에퍼메랄 포트로 자동 할당된다.  

```
$ docker container run -d -p 8080 node-nginx:test
```

## 도커 이미지 다루기 

도커 사용법은 크게 이미지를 다루는것과 컨테이너를 다루는 것으로 나눠 진다.  
도커 이미지는 도커 컨테이너를 만들기 위한 템플릿이다.  
도커 이미지는 우분투 같은 운영 체제로 구성된 파일 시스템은 물론, 컨테이너 위에서 실행하기 위한 애플리케이션이나 그 의존 라이브러리, 도구에 어떤 프로세스를 실행할지 등의 실행환경의 설정정보까지 포함하는 아카이브다.  

컨테이너의 템플릿역할을 하는 이미지를 만드는 과정을 일반적으로 `도커 이미지를 빌드한다.` 라고 한다.  그리고 컨테이너를 실행할 때 이 빌드된 이미지를 사용한다.  
이미지를 빌드하는 명령어인 docker image build 부터 시작해 이미지를 다루는 기본 명령을 하나씩 살펴볼 것이다. 그리고 마지막으로 도커 허브에 이미지를 등록하는 과정까지 수행해 봄으로써 직접 만든 이미지를 다른 사람이 이용할 수 있게 하는 단계를 목표로 한다.  

중요한것을 놓치기도 한다. 아래와 같이 검색한다.  

```
$ docker help
```  

### docker image build - 이미지 빌드
docker image build -t 이미지명[:태그명] Dockerfile의_경로  
실전 예제)  

```
$ docker image build -t example/echo:latest
```  

-f 옵션  
docker image build 명령은 기본으로 Dockerfile이라는 이름으로 된 Dockerfile을 찾는다. 그 외 파일명으로 된 Dockerfile을 사용하려면 -f 옵션을 사용해야 한다. 예를 들어 Dockerfile-test라는 이름으로 된 Dockerfile을 사용하려면 다음과 같이 한다.  

```
$ docker image build -f Dockerfile-test -t example/echo:latest .
```

--pull 옵션  
docker image build 명령으로 이미지를 빌드하려면 Dockerfile의 FROM 인스트럭션에 지정한 이미지를 레지스트리에서 내려받은 후, 이를 베이스 이미지로 해서 새로운 이미지를 빌드한다.  

이렇게 레지스트리에서 받아온 도커 이미지는 일부러 삭제하지 않는 한 호스트 운영 체제에 저장된다.  
그러므로 이미지를 빌드할 때 매번 베이스 이미지를 받아오지는 않는다. 그러나 --pull 옵션을 사용하면 매번 베이스 이미지를 강제로 새로 받아온다.  

```
$ docker image build --pull=true -t example/echo:latest .
```  
### docker search - 이미지 검색

docker search 명령을 사용하면 도커 허브에 등록된 레포지토리를 검색할 수 있다.  

```
$ docker search --limit 5 mysql
```

### docker image pull - 이미지 내려받기

```
$ docker image pull jenkins:latest
```

### docker image ls - 보유한 도커 이미지 목록 보기

```
$ docker image ls
```

### docker image tag - 이미지에 태그 붙이기

```
$ docker image ls 
$ docker image tag example/echo:latest example/echo:0.1.0
```

### docker image push - 이미지를 외부에 공개하기

```
$ docker image tag example/echo:latest stormcattest/echo:latest
$ docker image push stormcattest/echo:lastest
```

> Dockerfile에는 패스워드나 API 키값 같은 민감한 정보가 포함되지 않도록 주의한다. 

## 도커 컨테이너 다루기







## 2. 쿠버네티스

## 3. 호스트

- AWS
  - 가입하기
  - EKS 설정하기
  - 컨테이너 올리기  

- 디지털오션

- GCP

- 알리클라우드

