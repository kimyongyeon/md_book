## 1. 자바스크립트 프론트엔드 개발 프레임워크의 최신동향
SPA라는 용어를 이 책에서 처음 접한 독자도 있을 것이다.
SPA와 관련된 분야는 조금 어려운 개념과 용어가 많다.

### 클라이언트 사이드 라우팅
웹 애플리케이션, 그 중에서도 서버 사이드 분야에서 "라우팅"이라고 하면 사용자의 요청이 들어온 URL에 대해 적절한 응답(HTML 혹은 JSON)을 돌려주기 위해 어떤 처리와 매치시킬지를 결정하는 과정을 가리킨다. 그러나 최근에 클라이언트 사이드(즉, 프론트엔트)에서도 라우팅이라는 용어가 사용되고 있다.

### CSS in JS
CSS in JS란 문자 그대로 자바스크립트에 CSS가 내장된 것으로, 여러 라이브러리에서 각각 다른 작성법을 지원한다. 

#### 컴포넌트 지향
객체 지향이 객체와 객체의 상호작용 형태로 프로그램을 작성하듯이 "컴포넌트 지향" 역시 컴포넌트와 컴포넌트 간의 상호작용 형태로 프로그램을 작성합니다. 

컴포넌트란 도대체 무엇인가?
컴포넌트 개념을 도입한 UI 프레임워크 중 가장 널리 쓰이는 것이 Bootstrap 이다. Bootstrap의 컴포넌트는 HTML과 CSS, 그리고 약간의 자바스크립트로 구성된다. 그럼 Bootstrap 에서 구현되어 있는 컴포넌트들 그저 늘어놓는 것만으로 애플리케이션이 완성되는가 하면, 그렇지는 않다. 컴포넌트를 늘어놓는 것만으로는 컴포넌트 간의 상호작용이 없기 때문이다. 

예를들어 라디오 버튼에 체크될 때 송신 버튼이 클릭할 수 있는 상태가 되는 동작은 두 컴포넌트 사이의 상호작용이 있어야 가능하다. 이렇듯 컴포넌트가 주체가 되어 컴포넌트 사이의 관계로 애플리케이션 전체를 구성하는 것을 "컴포넌트 지향"이라고 한다. 

컴포넌트 지향에서는 애플리케이션의 기본 정보를 포함하는 페이지를 통째로 하나의 컴포넌트(루트 컴포넌트)로 정의한다. 이 루트 컴포넌트 안에 다른 컴포넌트를 포함시키는 형태로 컴포넌트 간의 부모관계 및 형제관계를 형성하고 컴포넌트 사이의 상호작용을 정의하여 애플리케이션 애플리케이션을 만든다.

외양과 행동을 컴포넌트 내부에 감추어 두는 "캡슐화"가 필요하게 되었다. 이렇게 구현된 이유는 프레임워크 설계에 컴포넌트 지향이 반영되어 있기 때문이다. 

#### SSR과 프리 렌더링
SSR은 서버 사이드 렌더링의 약자이다. SSR을 이해하려면 일반적인 HTTP 응답 이야기를 먼저 해야 한다. 일반적인 웹 어플리케이션에서는 사용자가 브라우저를 통해 접근하는 콘텐츠가 이미 삽입된 HTML을 응답으로 받아온다. 즉, SPA로 치면 이미 렌더링이 끝난 HTML을 받아오는 것이다. 이와 달리 SPA 에서는 알맹이가 빈 HTML을 응답으로 받는다. 

```html
<div id="app"></div>
```

이 HTML의 #app 안에 SPA의 콘텐츠가 삽입되어 HTML이 동적으로 생성된다. 그래서 클라이언트 측에서 렌더링이 이루어진다고 표현하는 것이다.
여기까지는 일반적인 SPA의 경우이다. 클라이언트 측에서 렌더링할 때 문제점은 페이지 표시 속도와 크롤러가 대응하지 못하는 것을 들 수 있다. 페이지 표시 속도면을 생각해보면 빈 HTML이 먼저 표시된 다음에 콘텐츠가 렌더링되므로 전체 HTML이 바로 표시되는 경우에 비해 속도가 느려진다. 콘텐츠가 API를 경유하여 전달된 다음 렌더링된다면 더욱 속도가 느려진다. 

클롤러 대응과 관련해서는 두 가지 문제가 있다. 첫 번째는 SEO(검색엔진최적화) 문제이다. 즉, 페이지가 검색 결과에 잘 포함될 지 여부이다. 또 한가지 문제는 SNS에 대한 문제로, 정상적으로 웹 페이지가 공유되는지 여부이다. SEO와 관련된 문제는 주로 구글과 관련된 것이다. 그러나 구글은 자바스크립트로 렌더링된 페이지도 정상적으로 수집해 주므로 SPA 콘텐츠도 검색 대상이 된다. 

그러나 SNS와 관련된 문제는 쉽게 해결되지 않는다. 대부분의 SNS 크롤러는 URL에 접근하여 얻은 응답 결과를 바로 인덱싱하기 때문이다. 
다시 말해 wget이나 curl같은 명령행 도구로 URL에 접근했을 때나 마찬가지가 된다. 이런 경우에 별도 대책을 세워놓지 않은 SPA는 자바스크립트가 채 실행도기 전에 페이지가 수집된다. 서버로부터 들어오는 HTML은 (콘텐츠가 들어갈 자리에) 빈 div요소가 있기 때문이다. 트위터와 페이스북에서 페이지 공유 시에 사용되는 썸네일 수집용 크롤러가 여기에 해당한다. 

SPA 약점은 기계가독성이 낮다는 점이다. 크롤러의 유형과 상관없이 서버에서 클라이언트로 전달되는 응답 결과에 이미 (콘텐츠까지) 렌더링을 마친 상태를 전달한다. 
이를 구현하려면 어떤 방법으로든 서버측에서 SPA에서 만들 렌더링 결과를 완성해야 한다. 이를 위해 React에는 ReactDOMServer가 있고 Vuejs에는 vue-server-renderer angular에는 Angular Universal 이 갖춰져 있다.

프리 렌더링은 말 그대로 미리 렌더링 해놓는다. 라는 뜻이다. 하지만 서버 사이드 렌더링과는 달리 서버에 렌더링 로직이 존재하지 않는다. 요청이 들어왔을 때 대상이 클로러인지 판단하여 크롤러인 경우 가상 브라우저로 접근하는 방식으로 생성한 다음 저장해둔 렌더링 결과를 제공하는 방식이다. 프리 렌더링을 제공하는 서비스로 Prerender를 들 수 있다. 

#### 가상 DOM
가상 DOM(Virtual DOM)은 자바스크립트가 HTML을 렌더링하는 방법 중 하나이다. React에서 가상 DOM을 채택하고부터 주목을 받게 되었다. React에서는 React가 관리하는 HTML의 DOM요소를 다른 영역에 가상화된 DOM 요소를 통해 관리한다. HTML을 직접 수정하는데 익숙한 사람은 왜 그리 번잡한 과정을 거쳐야 하는지 이해가 잘 가지 않을 것이다. 

그 이유는 실제 DOM을 수정하는 과정이 자바스크립트에서 메모리 상의 객체를 수정하는 것보다 휠씬 오래 걸리기 때문이다. 그러므로 일단 메모리 상에 있는 DOM 구조를 업데이트한 다음, 가상 DOM의 현재 상태와 이전 상태의 차이를 구해서 그 차이만을 실제 DOM에 반영하여 효율적으로 DOM을 수정할 수 있따.

가상 DOM을 도입하여 일어난 변화는 DOM 수정 연산의 성능 향상뿐만이 아니다. 자바스크립트가 DOM에 접근하여 그 내용물을 수정하는 기존의 방법은 가상 DOM의 용도와는 맞지 않는다. 어떤 데이터를 인자로 넘기면 HTML 구조 전체를 변환하는 함수만 있다면 나머지는 가상 DOM이 어디를 수정할지 관리하고 직접 수정까지 해줄 것이기 때문이다. 이것은 패러다임의 변화라 할 정도로 상당한 변화이다. React의 부상은 이러한 함수를 중심으로 한 스타일 때문이기도 하다. 

가상 DOM은 React뿐만 아니라 Vue.js에서도 사용되며, 이 외에도 Maquette와 hyperHTML등 다양한 라이브러리에서 쓰이고 있다. 

#### MVC와 MVP, MVVM
각종 프레임워크를 검색하다 보면 "XXX는 MVP프레임워크"라는 식의 문장을 자주 보게 된다. 이런 문장에는 MVC, MVP, MVVM과 같은 약어가 많이 등장하는데, 이번 절에서는 웹 애플리케이션에서 말하는 MVC가 무엇인지 짚어보고, 프론트앤드 애플리케이션의 MVP,MVVM이 무엇인지 알아보도록 한다. 

우선 일반적인 웹 애플리케이션에서 말하는 MVC가 무엇인지 알아보자. MVC 프레임워크라는 용어는 루비 온 레일즈의 붐과 함께 폭발적으로 확산되었다. MVC라는 용어 자체는 RoR 이전에도 있었지만 RoR의 캐치프레이즈와 같은 역할을 했다. 

#### 웹 애플리케이션 MVC
MVC란 Model View Controller (모델-뷰-컨트롤러)의 약자이다. 

Model: 데이터와 데이터에 접근하기 위한 기능
View: 콘텐츠를 어떻게 외부에 출력할지를 정의하는 부분
Controller: 특정 URL을 요청받았을 때(이 과정을 '라우팅'이라고 한다.)

#### 프론트엔드 애플리케이션에서의 MV
프론트엔드 애플리케이션에서 말하는 MV(Model-View)는 MVC 애플리케이션의 뷰 부분에 해당한다. 웹 애플리케이션은 본래 콘텐츠가 HTML에 포함된 채로 사용자에게 응답으로 전달되기 때문에 '뷰'안에 MV와 같은 구성을 할 필요가 없었다. 

그러나 SPA에서는 '뷰' 안에서도 Ajax 등을 통한 데이터 접근 계층이 추가되거나 필요에 따라 URL을 교체하는 처리 등이 끼어들기 때문에 MV 구조가 필요하게 되었다.

#### MVP 패턴
P: 프리젠터, 모델과 뷰 사이에 프리젠터가 위치하여 양자 간의 입출력 인터페이스 역할을 맡는다. 

#### MVVP 패턴
뷰모델: 프리젠터와 비슷하지만, 그 역할이 뷰와 모델 간의 인터페이스 대신 양방향 데이터 바인딩을 담당한다는 점이 다르다. 

#### Flux 
액션크리에이터, 디스패처, 스토어, 뷰 단계를 반복하는 형태로 웹애플리케이션이 구성된다. 
액션크리에이터: 액션을 생성하는 함수
디스패처: 액션을 넘겨받아 스토어의 내용을 변경할 수 있다. 
스토어: 애플리케이션의 상태를 나타내는 정보를 말한다. 
뷰: 화면을 가르킨다. 



##### 2. 자바스크립트 프론트엔드 개발을 위한 기초 지식 및 환경 구축

##### 3. Slack 스타일의 예제를 만들어보며 React / Angular / Vue.js 익히기

##### 4. Slck 스타일의 예제를 만들어보며 React Native 배우기 
